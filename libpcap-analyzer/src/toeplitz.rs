/// Maximum key size used throughout.  It's OK for hardware to use only the
/// first 16 bytes, which is all that's required for IPv4.
pub const RSS_KEYSIZE: usize = 40;

// // original Microsoft's key
// pub const KEY_OLD : &[u8] = &[
//         0x6d, 0x5a, 0x56, 0xda, 0x25, 0x5b, 0x0e, 0xc2,
//         0x41, 0x67, 0x25, 0x3d, 0x43, 0xa3, 0x8f, 0xb0,
//         0xd0, 0xca, 0x2b, 0xcb, 0xae, 0x7b, 0x30, 0xb4,
//         0x77, 0xcb, 0x2d, 0xa3, 0x80, 0x30, 0xf2, 0x0c,
//         0x6a, 0x42, 0xb7, 0x3b, 0xbe, 0xac, 0x01, 0xfa,
//         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//         0x00, 0x00, 0x00, 0x00
// ];

// key from http://www.ndsl.kaist.edu/~shinae/papers/TR-symRSS.pdf
//
// Letâ€™s assume we have a frame IP source: 1.1.1.1, IP destination: 2.2.2.2 and UDP port 22 to udp
// port 55. This means that the input for the hash function of the 4 tupples will be:
// [1.1.1.1][2.2.2.2][22][55] and for the opposite direction: [2.2.2.2][1.1.1.1][55][22]. To
// support the same hash value for these two inputs, the first 32bit of the key need to be
// identical to the second 32bit, and the 16bit afterwards should be identical to the next 16bit.
#[rustfmt::skip]
pub const KEY : &[u8] = &[
        0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 
        0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 
        0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 
        0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 
        0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 0x6d, 0x5a, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
];

/// Toeplitz (RSS) hash algorithm
pub fn toeplitz_hash(key: &[u8], data: &[u8]) -> u32 {
    let mut hash: u32 = 0;
    let mut v = (u32::from(key[0]) << 24)
        | (u32::from(key[1]) << 16)
        | (u32::from(key[2]) << 8)
        | u32::from(key[3]);
    for i in 0..data.len() {
        for b in 0..8 {
            if data[i] & (1 << (7 - b)) != 0 {
                hash ^= v;
            }
            v <<= 1;
            if (i + 4) < RSS_KEYSIZE && (key[i + 4] & (1 << (7 - b))) != 0 {
                v |= 1;
            }
        }
    }
    hash
}

#[cfg(test)]
mod tests {
    use super::toeplitz_hash;
    // original Microsoft's key
    #[rustfmt::skip]
    pub const KEY_OLD : &[u8] = &[
        0x6d, 0x5a, 0x56, 0xda, 0x25, 0x5b, 0x0e, 0xc2,
        0x41, 0x67, 0x25, 0x3d, 0x43, 0xa3, 0x8f, 0xb0,
        0xd0, 0xca, 0x2b, 0xcb, 0xae, 0x7b, 0x30, 0xb4,
        0x77, 0xcb, 0x2d, 0xa3, 0x80, 0x30, 0xf2, 0x0c,
        0x6a, 0x42, 0xb7, 0x3b, 0xbe, 0xac, 0x01, 0xfa,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    ];
    #[test]
    fn toeplitz_hash_test() {
        const DATA1: &[u8] = &[66, 9, 149, 187, 161, 142, 100, 80, 10, 234, 6, 230];
        let res = toeplitz_hash(KEY_OLD, DATA1);
        assert_eq!(res, 0x51cc_c178);
        const DATA2: &[u8] = &[199, 92, 111, 2, 65, 69, 140, 83, 55, 150, 18, 131];
        let res = toeplitz_hash(KEY_OLD, DATA2);
        assert_eq!(res, 0xc626_b0ea);
    }
}
